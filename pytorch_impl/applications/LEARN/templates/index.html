<!DOCTYPE html>
<html>
  <head>
    <title>Garfield Demonstrator</title>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-material@1.0.0-beta-15"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuelidate@0.7.6/dist/vuelidate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuelidate@0.7.6/dist/validators.min.js"></script>

    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic|Material+Icons"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/vue-material/dist/vue-material.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/vue-material/dist/theme/default.css"
    />

    <style>
      .garfield-center {
        margin: auto;
        text-align: center;
      }

      body {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      div#app {
        width: 80%;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
        margin-top: 3vh;
        margin-bottom: 3vh;
      }

      .md-toolbar {
        justify-content: center;
      }
      .md-steppers {
        flex: 1 1 auto;
      }
      .md-stepper-header.md-active {
        font-weight: bold;
        background-color: #f6f6f6;
      }
      .md-dialog-title {
        align-self: center;
      }
      .md-drawer.md-theme-default {
        margin-right: 1em;
      }
      .md-content#results {
        display: flex;
        flex-direction: row;
        justify-content: left;
      }
      .md-card {
        margin: 0.5em;
      }
      div#servers {
        display: flex;
        flex-direction: row;
        align-items: center;
      }
      i#reliable-node {
        color: var(--md-theme-default-primary-on-background, #448aff);
        margin: 0 0.2ch 0 0.2ch;
      }
      i#byzantine-node {
        color: var(--md-theme-default-primary-on-background, #ff5252);
        margin: 0 0.2ch 0 0.2ch;
      }
      div.separator {
        border-left: 1px solid black;
        height: 2em;
        margin: 0 1ch 0 1ch;
      }
      div.form-submit {
        height: 2em;
      }
    </style>
  </head>

  <body>
    <div id="app">
      <md-toolbar>
        <h3 class="md-display-1">Garfield Demonstrator</h3>
      </md-toolbar>

      <md-dialog
        :md-active.sync="showProgressDialog"
        :md-close-on-esc="false"
        :md-click-outside-to-close="false"
      >
        <md-dialog-title>Training...</md-dialog-title>
        <md-progress-bar
          :md-mode="progressMode"
          :md-value="progressValue"
        ></md-progress-bar>
        <div class="md-body-2 garfield-center">[[ progressStatus ]]</div>
      </md-dialog>

      <md-dialog-alert
        :md-active.sync="showErrorDialog"
        md-title="An error occurred, please try again"
        :md-content="errorMessage"
      >
      </md-dialog-alert>

      <md-steppers :md-active-step.sync="currentStep" md-linear>
        <md-step id="intro" md-label="Introduction">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-content>
              <p>
                [Describe what use case the demonstrator illustrates, and what
                the user will be able to do and see during the demonstration.]
              </p>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step
          id="simple"
          md-label="Simple training"
          :md-done="simpleTrainingResult !== null"
        >
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                In this step, we will train a model on data from the
                <a
                  href="https://www.kaggle.com/uciml/pima-indians-diabetes-database"
                  >Pima Indian Diabetes dataset.</a
                >. This data consists of several patient medical values (such as
                number of pregnancies, age, etc.), and indicates for each
                patient whether they had diabetes.
              </p>
            </md-app-drawer>

            <md-app-content>
              <p>
                We will use a subset of the data to train the model, and use the
                rest as test values to evaluate how well our model can predict
                the outcome.
              </p>

              <form @submit.prevent="runSimpleTraining">
                <div class="form-submit"></div>
                <md-button type="submit" class="md-raised md-primary"
                  >Train</md-button
                >
              </form>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step
          id="multi"
          md-label="Adding data"
          :md-done="multiNodeTrainingResult !== null"
        >
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                If we can add data from other sources, the accuracy will likely
                improve, but we don't always want to share data [elaborate on
                federated learning bla bla bla].
              </p>
            </md-app-drawer>

            <md-app-content>
              <p>
                Click to select the number of additional datasets with which you
                would like to train:
              </p>

              <form @submit.prevent="runMultiNodeTraining">
                <div id="servers">
                  Original system
                  <md-icon class="md-size-2x" id="reliable-node"
                    >storage</md-icon
                  >

                  <div class="separator"></div>

                  <md-button
                    class="md-raised"
                    v-for="idx in 5"
                    @click="setN(idx)"
                  >
                    <md-icon
                      class="md-size-2x"
                      v-bind:class="{'md-primary': idx <= form.n}"
                      >storage</md-icon
                    >
                  </md-button>
                  [[ form.n ]] additional system(s)
                </div>

                <div class="form-submit"></div>
                <md-button type="submit" class="md-raised md-primary"
                  >Train</md-button
                >
              </form>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step
          id="byz"
          md-label="Byzantine behavior"
          :md-done="byzantineTrainingResult !== null"
        >
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                [Explain Byzantine failures in general terms, relating to
                real-life use cases.]
              </p>
              <p>
                [Explain that Byzantine components can adversely affect the
                learning if the system is not prepared for it.]
              </p>
            </md-app-drawer>

            <md-app-content>
              <p>
                We have currently [[ Number(form.n) + 1 ]] datasets, each served
                by reliable systems. Click to select the number of these systems
                which you would like to exhibit failures:
              </p>

              <form @submit.prevent="runByzantineTraining">
                <div id="servers">
                  [[ form.f ]] unreliable system(s)
                  <md-button
                    class="md-raised"
                    v-for="idx in form.n"
                    @click="setF(idx)"
                  >
                    <md-icon
                      class="md-size-2x"
                      v-bind:class="{'md-accent': idx <= form.f, 'md-primary': idx > form.f}"
                      >storage</md-icon
                    >
                  </md-button>

                  <div class="separator"></div>

                  <md-icon class="md-size-2x" id="reliable-node"
                    >storage</md-icon
                  >
                </div>

                <div class="form-submit"></div>
                <md-button type="submit" class="md-raised md-primary"
                  >Train</md-button
                >
              </form>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step
          id="byzres"
          md-label="Byzantine resilience"
          :md-done="byzantineTolerantTrainingResult !== null"
        >
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                [Explain that Garfield is designed to be applied with any ML
                algorithm to render it resilient to Byzantine failures.]
              </p>
            </md-app-drawer>
            <md-app-content>
              <p>
                We have currently [[ Number(form.n) + 1 ]] systems, of which [[
                form.f ]] exhibit failures.
              </p>
              <div id="servers">
                <md-icon
                  v-for="idx in form.n + 1"
                  class="md-size-2x"
                  v-bind:id="getNodeId(idx)"
                >
                  storage</md-icon
                >
              </div>
              <p>
                We will now make use of Garfield's ability to train a model even
                though some of the systems exhibit failures.
              </p>

              <form @submit.prevent="runByzantineTolerantTraining">
                <div class="form-submit"></div>
                <md-button type="submit" class="md-raised md-primary"
                  >Train</md-button
                >
              </form>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="end" md-label="Conclusion">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-content>
              <p>
                [Describe the differences with other projects such as Spindle,
                the pros and cons of each solution.]
              </p>
            </md-app-content>
          </md-app>
        </md-step>
      </md-steppers>

      <md-content v-if="simpleTrainingResult">
        <md-divider class="md-inset"></md-divider>
        <div class="md-subheading">Results:</div>

        <md-content id="results">
          <md-card
            v-bind:class="{'md-primary': currentStep === 'simple'}"
            v-if="simpleTrainingResult"
          >
            <md-card-header
              ><div class="md-body-2">Single system</div></md-card-header
            >
            <md-card-content>
              <div class="md-body-1">[[ simpleTrainingResult ]] accuracy</div>
            </md-card-content>
          </md-card>

          <md-card
            v-bind:class="{'md-primary': currentStep === 'multi'}"
            v-if="multiNodeTrainingResult"
          >
            <md-card-header
              ><div class="md-body-2">
                [[ Number(form.n) + 1 ]] reliable systems
              </div></md-card-header
            >
            <md-card-content>
              <div class="md-body-1">
                [[ multiNodeTrainingResult ]] accuracy
              </div>
            </md-card-content>
          </md-card>

          <md-card
            v-bind:class="{'md-primary': currentStep === 'byz'}"
            v-if="byzantineTrainingResult"
          >
            <md-card-header
              ><div class="md-body-2">
                [[ Number(form.n) + 1 ]] systems, [[ Number(form.f) ]] of which
                unreliable
              </div></md-card-header
            >
            <md-card-content>
              <div class="md-body-1">
                [[ byzantineTrainingResult ]] accuracy
              </div>
            </md-card-content>
          </md-card>

          <md-card
            v-bind:class="{'md-primary': currentStep === 'byzres'}"
            v-if="byzantineTolerantTrainingResult"
          >
            <md-card-header
              ><div class="md-body-2">
                [[ Number(form.n) + 1 ]] systems, [[ Number(form.f) ]] of which
                unreliable, with byzantine-tolerance
              </div></md-card-header
            >
            <md-card-content>
              <div class="md-body-1">
                [[ byzantineTolerantTrainingResult ]] accuracy
              </div>
            </md-card-content>
          </md-card>
        </md-content>
      </md-content>

      <md-toolbar>
        <md-button
          class="md-raised"
          :disabled="backDisabled"
          v-on:click="prevStep"
          >Back</md-button
        >
        <p>Step [[ currentStepIndex + 1 ]] / [[ steps.length ]]</p>
        <md-button
          class="md-raised"
          :disabled="nextDisabled"
          v-on:click="nextStep"
          >Next</md-button
        >
      </md-toolbar>
    </div>

    <script>
      Vue.use(VueMaterial.default);
      Vue.use(window.vuelidate.default);

      var app = new Vue({
        el: "#app",
        delimiters: ["[[", "]]"],
        data: {
          steps: ["intro", "simple", "multi", "byz", "byzres", "end"],
          stepTitles: [
            "Introduction",
            "Simple training",
            "Adding data",
            "Byzantine behavior",
            "Byzantine resilience",
            "Comparison to other projects",
          ],
          currentStep: "intro",
          form: {
            n: 1,
            f: 1,
            gar: "average",
          },
          showProgressDialog: false,
          progressMode: "query",
          progressValue: 0,
          progressStatus: "",
          simpleTrainingResult: null,
          multiNodeTrainingResult: null,
          byzantineTrainingResult: null,
          byzantineTolerantTrainingResult: null,
          trainingResult: null,
          showErrorDialog: false,
          errorMessage: null,
        },
        computed: {
          currentStepIndex: function () {
            return this.steps.indexOf(this.currentStep);
          },
          backDisabled: function () {
            return this.currentStepIndex === 0;
          },
          nextDisabled: function () {
            switch (this.currentStep) {
              case "simple":
                return this.simpleTrainingResult === null;
              case "multi":
                return this.multiNodeTrainingResult === null;
              case "byz":
                return this.byzantineTrainingResult === null;
              case "byzres":
                return this.byzantineTolerantTrainingResult === null;
              case "end":
                return true;
              default:
                return false;
            }
          },
          stepTitle: function () {
            return this.stepTitles[this.currentStepIndex];
          },
        },
        methods: {
          nextStep: function () {
            let idx = this.currentStepIndex + 1;
            if (idx >= this.steps.length) {
              idx = this.steps.length - 1;
            }
            this.currentStep = this.steps[idx];
          },
          prevStep: function () {
            let idx = this.currentStepIndex - 1;
            if (idx < 0) {
              idx = 0;
            }
            this.currentStep = this.steps[idx];
          },
          setN: function (idx) {
            this.form.n = idx;
            this.form.f = 1;
            this.clearResults();
          },
          setF: function (idx) {
            this.form.f = idx;
            this.clearResults();
          },
          getNodeId: function (idx) {
            return idx <= this.form.f ? "byzantine-node" : "reliable-node";
          },
          sendTrainingQuery: async function (query) {
            const response = await fetch("{{ url_for('train') }}", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(query),
            });

            let data;
            try {
              data = await response.json();
            } catch (e) {
              data = { error: "Unknown error" };
            }

            if (response.ok && data.error === undefined) {
              return data.trainerId;
            } else {
              this.showProgressDialog = false;
              this.showErrorDialog = true;
              this.errorMessage = data.error;
            }
          },
          clearResults: function () {
            switch (this.currentStep) {
              case "simple":
                this.simpleTrainingResult = null;
              // Fall-through
              case "multi":
                this.multiNodeTrainingResult = null;
              // Fall-through
              case "byz":
                this.byzantineTrainingResult = null;
              // Fall-through
              case "byzres":
                this.byzantineTolerantTrainingResult = null;
              // Fall-through
            }
          },
          runSimpleTraining: async function () {
            this.clearResults();

            const query = {
              n: 1,
              f: 0,
              gar: "average",
            };

            const trainerId = await this.sendTrainingQuery(query);
            if (trainerId !== undefined) {
              this.followProgress(trainerId).then((result) => {
                this.simpleTrainingResult = `${result.toFixed(1)}%`;
              });
            }
          },
          getValidationClass: function (fieldName) {
            const field = this.$v.form[fieldName];

            if (field) {
              return {
                "md-invalid": field.$invalid && field.$dirty,
              };
            }
          },
          runMultiNodeTraining: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              this.clearResults();

              const query = {
                n: Number(this.form.n) + 1,
                f: 0,
                gar: "average",
              };

              const trainerId = await this.sendTrainingQuery(query);
              if (trainerId !== undefined) {
                this.followProgress(trainerId).then((result) => {
                  this.multiNodeTrainingResult = `${result.toFixed(1)}%`;
                });
              }
            }
          },
          runByzantineTraining: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              this.clearResults();

              const query = {
                n: Number(this.form.n) + 1,
                f: Number(this.form.f),
                gar: "average",
              };

              const trainerId = await this.sendTrainingQuery(query);
              if (trainerId !== undefined) {
                this.followProgress(trainerId).then((result) => {
                  this.byzantineTrainingResult = `${result.toFixed(1)}%`;
                });
              }
            }
          },
          runByzantineTolerantTraining: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              this.clearResults();

              const query = {
                n: Number(this.form.n) + 1,
                f: Number(this.form.f),
                gar: "median",
              };

              const trainerId = await this.sendTrainingQuery(query);
              if (trainerId !== undefined) {
                this.followProgress(trainerId).then((result) => {
                  this.byzantineTolerantTrainingResult = `${result.toFixed(
                    1
                  )}%`;
                });
              }
            }
          },
          followProgress: async function (trainerId) {
            // Memorize Vue's `this`
            const this_ = this;

            const f = async function (resolve, reject) {
              var response = await fetch(
                `{{ url_for("get_status") }}?trainer_id=${trainerId}`
              );
              var data = await response.json();

              if (data.error !== undefined) {
                this_.showProgressDialog = false;
                this_.showErrorDialog = true;
                this_.errorMessage = data.error;
              } else if (data.result !== undefined) {
                this_.showProgressDialog = false;
                resolve(data.result);
              } else {
                this_.progressValue = data.progress;

                switch (data.progress) {
                  case -1:
                    this_.progressStatus = "Initializing...";
                    this_.progressMode = "query";
                    break;

                  case 100:
                    this_.progressStatus = "Finalizing...";
                    this_.progressMode = "query";
                    break;

                  default:
                    this_.progressStatus = `${data.progress}%`;
                    this_.progressMode = "determinate";
                    break;
                }

                setTimeout(f, 500, resolve, reject);
              }
            };

            this.showProgressDialog = true;

            return new Promise(f);
          },
        },
        validations: function () {
          return {
            form: {
              n: {
                required: validators.required,
                between: validators.between(1, 5),
              },
              f: {
                required: validators.required,
                between: validators.between(1, Number(this.form.n) + 1),
              },
              gar: {
                required: validators.required,
              },
            },
          };
        },
      });
    </script>
  </body>
</html>
