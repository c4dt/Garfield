<!DOCTYPE html>
<html>
  <head>
    <title>Garfield Demonstrator</title>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-material@1.0.0-beta-15"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuelidate@0.7.6/dist/vuelidate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuelidate@0.7.6/dist/validators.min.js"></script>

    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic|Material+Icons"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/vue-material/dist/vue-material.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/vue-material/dist/theme/default.css"
    />

    <style>
      .garfield-center {
        margin: auto;
        text-align: center;
      }

      .md-app {
        height: 67vh;
      }
      .md-toolbar {
        justify-content: center;
      }
    </style>
  </head>

  <body>
    <div id="app">
      <md-toolbar>
        <h3 class="md-display-1">Garfield Demonstrator</h3>
      </md-toolbar>

      <md-dialog
        :md-active.sync="showProgressDialog"
        :md-close-on-esc="false"
        :md-click-outside-to-close="false"
      >
        <md-dialog-title>Training progress</md-dialog-title>
        <md-progress-bar
          :md-mode="progressMode"
          :md-value="progressValue"
        ></md-progress-bar>
        <div class="md-body-2 garfield-center">[[ progressStatus ]]</div>
      </md-dialog>

      <md-dialog-alert
        :md-active.sync="showErrorDialog"
        md-title="An error occurred, please try again"
        :md-content="errorMessage"
      >
      </md-dialog-alert>

      <md-steppers :md-active-step.sync="currentStep" md-linear>
        <md-step id="one" md-label="Introduction">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-content>
              <p>
                [Describe what use case the demonstrator illustrates, and what
                the user will be able to do and see during the demonstration.]
              </p>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="two" md-label="Simple training">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              In this step, we will train a model on a known set of images, and
              see how well it can label a new set of images.
            </md-app-drawer>
            <md-app-content> This is the contents </md-app-content>
          </md-app>
        </md-step>

        <md-step id="three" md-label="Adding data">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                If we can add data from other sources, the accuracy will likely
                improve, but we don't always want to share data [elaborate on
                federated learning bla bla bla].
              </p>
              <p>
                Select the number of additional datasets with which you would
                like to train.
              </p>
            </md-app-drawer>
            <md-app-content>
              <form @submit.prevent="validateData">
                <md-field :class="getValidationClass('n')">
                  <label for="n">Total number of nodes:</label>
                  <md-input
                    type="number"
                    id="n"
                    name="n"
                    v-model="$v.form.n.$model"
                  ></md-input>
                  <span class="md-error" v-if="!$v.form.n.required"
                    >n is required</span
                  >
                  <span class="md-error" v-else-if="!$v.form.n.between"
                    >n must be between [[ $v.form.n.$params.between.min ]] and
                    [[ $v.form.n.$params.between.max ]]</span
                  >
                </md-field>
                <md-field :class="getValidationClass('f')">
                  <label for="f">Number of byzantine nodes:</label>
                  <md-input
                    type="number"
                    id="f"
                    name="f"
                    v-model="$v.form.f.$model"
                  ></md-input>
                  <span class="md-error" v-if="!$v.form.f.required"
                    >f is required</span
                  >
                  <span class="md-error" v-else-if="!$v.form.f.between"
                    >f must be between [[ $v.form.f.$params.between.min ]] and
                    the total number of nodes (i.e. currently [[
                    $v.form.f.$params.between.max ]])</span
                  >
                </md-field>
                <md-field :class="getValidationClass('gar')">
                  <label for="aggregator">Aggregator:</label>
                  <md-select
                    name="gar"
                    id="aggregator"
                    md-dense
                    v-model="$v.form.gar.$model"
                  >
                    <md-option value="average">average</md-option>
                    <md-option value="median">median</md-option>
                  </md-select>
                </md-field>
                <span class="md-error" v-if="!$v.form.gar.required"
                  >The aggregator is required</span
                >
                <md-button type="submit" class="md-primary">Train</md-button>
              </form>

              <div class="md-headline" v-if="trainingResult">
                Model accuracy after training: [[ trainingResult ]]
              </div>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="four" md-label="Byzantine behavior">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                [Explain Byzantine failures in general terms, relating to
                real-life use cases.]
              </p>
              <p>
                [Explain that Byzantine components can adversely affect the
                learning if the system is not prepared for it.]
              </p>
              <p>
                We have currently [[ nbDatasets ]] datasets, each served by
                reliable systems. Select the number of these systems which you
                would like to exhibit failures.
              </p>
            </md-app-drawer>
            <md-app-content> This is the contents </md-app-content>
          </md-app>
        </md-step>

        <md-step id="five" md-label="Byzantine resilience">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                [Explain that Garfield is designed to be applied with any ML
                algorithm to render it resilient to Byzantine failures.]
              </p>
              <p>
                We have currently [[ nbDatasets ]], of which [[ nbByzantine ]]
                exhibit failures.
              </p>
            </md-app-drawer>
            <md-app-content> This is the contents </md-app-content>
          </md-app>
        </md-step>

        <md-step id="six" md-label="Conclusion">
          <h3 class="md-headlin garfield-centere">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-content>
              <p>
                [Describe the differences with other projects such as Spindle,
                the pros and cons of each solution.]
              </p>
            </md-app-content>
          </md-app>
        </md-step>
      </md-steppers>

      <md-toolbar>
        <md-button
          class="md-raised"
          :disabled="backDisabled"
          v-on:click="prevStep"
          >Back</md-button
        >
        <p>Step [[ steps.indexOf(currentStep) + 1 ]] / [[ steps.length ]]</p>
        <md-button
          class="md-raised"
          :disabled="nextDisabled"
          v-on:click="nextStep"
          >Next</md-button
        >
      </md-toolbar>
    </div>

    <script>
      Vue.use(VueMaterial.default);
      Vue.use(window.vuelidate.default);

      var app = new Vue({
        el: "#app",
        delimiters: ["[[", "]]"],
        data: {
          nbDatasets: 3,
          nbByzantine: 1,
          steps: ["one", "two", "three", "four", "five", "six"],
          stepTitles: [
            "Introduction",
            "Simple training",
            "Adding data",
            "Byzantine behavior",
            "Byzantine resilience",
            "Comparison to other projects",
          ],
          currentStep: "one",
          form: {
            n: 0,
            f: 0,
            gar: "average",
          },
          showProgressDialog: false,
          progressMode: "query",
          progressValue: 0,
          progressStatus: "",
          trainingResult: null,
          showErrorDialog: false,
          errorMessage: null,
        },
        computed: {
          backDisabled: function () {
            return this.currentStep === this.steps[0];
          },
          nextDisabled: function () {
            return this.currentStep === this.steps[this.steps.length - 1];
          },
          stepTitle: function () {
            const index = this.steps.indexOf(this.currentStep);
            return this.stepTitles[index];
          },
        },
        methods: {
          nextStep: function () {
            const index = this.steps.indexOf(this.currentStep);
            this.currentStep = this.steps[index + 1];
          },
          prevStep: function () {
            const index = this.steps.indexOf(this.currentStep);
            this.currentStep = this.steps[index - 1];
          },
          getValidationClass: function (fieldName) {
            const field = this.$v.form[fieldName];

            if (field) {
              return {
                "md-invalid": field.$invalid && field.$dirty,
              };
            }
          },
          validateData: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              const response = await fetch("{{ url_for('train') }}", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(this.form),
              });
              const data = await response.json();
              this.showProgressDialog = true;
              this.checkProgress(data.trainerId);
            }
          },
          checkProgress: async function (trainerId) {
            var response = await fetch(
              `{{ url_for("get_status") }}?trainer_id=${trainerId}`
            );
            var data = await response.json();

            if (data.error !== undefined) {
              this.showProgressDialog = false;
              this.showErrorDialog = true;
              this.errorMessage = data.error;
            } else if (data.result !== undefined) {
              this.trainingResult = `${data.result.toFixed(1)}%`;
              this.showProgressDialog = false;
            } else {
              this.progressValue = data.progress;

              switch (data.progress) {
                case 0:
                  this.progressStatus = "Initializing...";
                  this.progressMode = "query";
                  break;

                case 100:
                  this.progressStatus = "Finalizing...";
                  this.progressMode = "query";
                  break;

                default:
                  this.progressStatus = `${data.progress}%`;
                  this.progressMode = "determinate";
                  break;
              }

              setTimeout(this.checkProgress, 1000, trainerId);
            }
          },
        },
        validations: function () {
          return {
            form: {
              n: {
                required: validators.required,
                between: validators.between(1, 5),
              },
              f: {
                required: validators.required,
                between: validators.between(0, this.form.n),
              },
              gar: {
                required: validators.required,
              },
            },
          };
        },
      });
    </script>
  </body>
</html>
