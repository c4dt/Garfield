<!DOCTYPE html>
<html>
  <head>
    <title>Garfield Demonstrator</title>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-material@1.0.0-beta-15"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuelidate@0.7.6/dist/vuelidate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuelidate@0.7.6/dist/validators.min.js"></script>

    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic|Material+Icons"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/vue-material/dist/vue-material.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/vue-material/dist/theme/default.css"
    />

    <style>
      .garfield-center {
        margin: auto;
        text-align: center;
      }

      .md-app {
        height: 67vh;
      }
      .md-toolbar {
        justify-content: center;
      }
    </style>
  </head>

  <body>
    <div id="app">
      <md-toolbar>
        <h3 class="md-display-1">Garfield Demonstrator</h3>
      </md-toolbar>

      <md-dialog
        :md-active.sync="showProgressDialog"
        :md-close-on-esc="false"
        :md-click-outside-to-close="false"
      >
        <md-dialog-title>Training in progress...</md-dialog-title>
        <md-progress-bar
          :md-mode="progressMode"
          :md-value="progressValue"
        ></md-progress-bar>
        <div class="md-body-2 garfield-center">[[ progressStatus ]]</div>
      </md-dialog>

      <md-dialog-alert
        :md-active.sync="showErrorDialog"
        md-title="An error occurred, please try again"
        :md-content="errorMessage"
      >
      </md-dialog-alert>

      <md-steppers :md-active-step.sync="currentStep" md-linear>
        <md-step id="one" md-label="Introduction">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-content>
              <p>
                [Describe what use case the demonstrator illustrates, and what
                the user will be able to do and see during the demonstration.]
              </p>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="two" md-label="Simple training">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                In this step, we will train a model on data from the
                <a
                  href="https://www.kaggle.com/uciml/pima-indians-diabetes-database"
                  >Pima Indian Diabetes dataset.</a
                >. This data consists of several patient medical values (such as
                number of pregnancies, age, etc.), and indicates for each
                patient whether they had diabetes.
              </p>
            </md-app-drawer>

            <md-app-content>
              <p>
                We will use a subset of the data to train the model, and use the
                rest as test values to evaluate how well our model can predict
                the outcome.
              </p>

              <form @submit.prevent="runSimpleTraining">
                <md-button type="submit" class="md-primary">Train</md-button>
              </form>

              <div class="md-headline" v-if="simpleTrainingResult">
                Model accuracy after training: [[ simpleTrainingResult ]]
              </div>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="three" md-label="Adding data">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                If we can add data from other sources, the accuracy will likely
                improve, but we don't always want to share data [elaborate on
                federated learning bla bla bla].
              </p>
            </md-app-drawer>

            <md-app-content>
              <p>
                Select the number of additional datasets with which you would
                like to train.
              </p>

              <form @submit.prevent="runMultiNodeTraining">
                <md-field :class="getValidationClass('n')">
                  <label for="n">Additional number of nodes:</label>
                  <md-input
                    type="number"
                    id="n"
                    name="n"
                    v-model="$v.form.n.$model"
                  ></md-input>
                  <span class="md-error" v-if="!$v.form.n.required"
                    >n is required</span
                  >
                  <span class="md-error" v-else-if="!$v.form.n.between"
                    >n must be between [[ $v.form.n.$params.between.min ]] and
                    [[ $v.form.n.$params.between.max ]]</span
                  >
                </md-field>

                <md-button type="submit" class="md-primary">Train</md-button>
              </form>

              <div class="md-headline" v-if="multiNodeTrainingResult">
                Model accuracy after training: [[ multiNodeTrainingResult ]]
              </div>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="four" md-label="Byzantine behavior">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                [Explain Byzantine failures in general terms, relating to
                real-life use cases.]
              </p>
              <p>
                [Explain that Byzantine components can adversely affect the
                learning if the system is not prepared for it.]
              </p>
            </md-app-drawer>

            <md-app-content>
              <p>
                We have currently [[ Number(form.n) + 1 ]] datasets, each served
                by reliable systems. Select the number of these systems which
                you would like to exhibit failures.
              </p>

              <form @submit.prevent="runByzantineTraining">
                <md-field :class="getValidationClass('f')">
                  <label for="f">Number of byzantine nodes:</label>
                  <md-input
                    type="number"
                    id="f"
                    name="f"
                    v-model="$v.form.f.$model"
                  ></md-input>
                  <span class="md-error" v-if="!$v.form.f.required"
                    >f is required</span
                  >
                  <span class="md-error" v-else-if="!$v.form.f.between"
                    >f must be between [[ $v.form.f.$params.between.min ]] and
                    the total number of nodes (i.e. currently [[
                    $v.form.f.$params.between.max ]])</span
                  >
                </md-field>

                <md-button type="submit" class="md-primary">Train</md-button>
              </form>

              <div class="md-headline" v-if="byzantineTrainingResult">
                Model accuracy after training: [[ byzantineTrainingResult ]]
              </div>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="five" md-label="Byzantine resilience">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-drawer md-permanent="clipped">
              <p>
                [Explain that Garfield is designed to be applied with any ML
                algorithm to render it resilient to Byzantine failures.]
              </p>
            </md-app-drawer>
            <md-app-content>
              <p>
                We have currently [[ Number(form.n) + 1 ]] systems, of which [[
                form.f ]] exhibit failures.
              </p>
              <p>
                We will now make use of Garfield's ability to train a model even
                though some of the systems exhibit failures.
              </p>

              <form @submit.prevent="runByzantineTolerantTraining">
                <md-button type="submit" class="md-primary">Train</md-button>
              </form>

              <div class="md-headline" v-if="byzantineTolerantTrainingResult">
                Model accuracy after training: [[
                byzantineTolerantTrainingResult ]]
              </div>
            </md-app-content>
          </md-app>
        </md-step>

        <md-step id="six" md-label="Conclusion">
          <h3 class="md-headline garfield-center">[[ stepTitle ]]</h3>
          <md-app>
            <md-app-content>
              <p>
                [Describe the differences with other projects such as Spindle,
                the pros and cons of each solution.]
              </p>
            </md-app-content>
          </md-app>
        </md-step>
      </md-steppers>

      <md-toolbar>
        <md-button
          class="md-raised"
          :disabled="backDisabled"
          v-on:click="prevStep"
          >Back</md-button
        >
        <p>Step [[ currentStepIndex + 1 ]] / [[ steps.length ]]</p>
        <md-button
          class="md-raised"
          :disabled="nextDisabled"
          v-on:click="nextStep"
          >Next</md-button
        >
      </md-toolbar>
    </div>

    <script>
      Vue.use(VueMaterial.default);
      Vue.use(window.vuelidate.default);

      var app = new Vue({
        el: "#app",
        delimiters: ["[[", "]]"],
        data: {
          steps: ["one", "two", "three", "four", "five", "six"],
          stepTitles: [
            "Introduction",
            "Simple training",
            "Adding data",
            "Byzantine behavior",
            "Byzantine resilience",
            "Comparison to other projects",
          ],
          currentStepIndex: 0,
          form: {
            n: 1,
            f: 1,
            gar: "average",
          },
          showProgressDialog: false,
          progressMode: "query",
          progressValue: 0,
          progressStatus: "",
          simpleTrainingResult: null,
          multiNodeTrainingResult: null,
          byzantineTrainingResult: null,
          byzantineTolerantTrainingResult: null,
          trainingResult: null,
          showErrorDialog: false,
          errorMessage: null,
        },
        computed: {
          currentStep: function () {
            return this.steps[this.currentStepIndex];
          },
          backDisabled: function () {
            return this.currentStepIndex === 0;
          },
          nextDisabled: function () {
            switch (this.currentStepIndex) {
              case 1:
                return this.simpleTrainingResult === null;
              case 2:
                return this.multiNodeTrainingResult === null;
              case 3:
                return this.byzantineTrainingResult === null;
              case 4:
                return this.byzantineTolerantTrainingResult === null;
              case this.steps.length - 1:
                return true;
              default:
                return false;
            }
          },
          stepTitle: function () {
            return this.stepTitles[this.currentStepIndex];
          },
        },
        methods: {
          nextStep: function () {
            this.currentStepIndex += 1;
            this.currentStepIndex %= this.steps.length;
          },
          prevStep: function () {
            // JavaScript's "%" is not a modulo, -1 % n === -1
            this.currentStepIndex -= 1 - this.steps.length;
            this.currentStepIndex %= this.steps.length;
          },
          runSimpleTraining: async function () {
            const query = {
              n: 1,
              f: 0,
              gar: "average",
            };
            const response = await fetch("{{ url_for('train') }}", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(query),
            });
            const data = await response.json();

            this.followProgress(data.trainerId).then((result) => {
              this.simpleTrainingResult = `${result.toFixed(1)}%`;
            });
          },
          getValidationClass: function (fieldName) {
            const field = this.$v.form[fieldName];

            if (field) {
              return {
                "md-invalid": field.$invalid && field.$dirty,
              };
            }
          },
          runMultiNodeTraining: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              const query = {
                n: Number(this.form.n) + 1,
                f: 0,
                gar: "average",
              };
              const response = await fetch("{{ url_for('train') }}", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(query),
              });
              const data = await response.json();

              this.followProgress(data.trainerId).then((result) => {
                this.multiNodeTrainingResult = `${result.toFixed(1)}%`;
              });
            }
          },
          runByzantineTraining: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              const query = {
                n: Number(this.form.n) + 1,
                f: Number(this.form.f),
                gar: "average",
              };
              const response = await fetch("{{ url_for('train') }}", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(query),
              });
              const data = await response.json();

              this.followProgress(data.trainerId).then((result) => {
                this.byzantineTrainingResult = `${result.toFixed(1)}%`;
              });
            }
          },
          runByzantineTolerantTraining: async function () {
            this.$v.$touch();

            if (!this.$v.$invalid) {
              const query = {
                n: Number(this.form.n) + 1,
                f: Number(this.form.f),
                gar: "median",
              };
              const response = await fetch("{{ url_for('train') }}", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(query),
              });
              const data = await response.json();

              this.followProgress(data.trainerId).then((result) => {
                this.byzantineTolerantTrainingResult = `${result.toFixed(1)}%`;
              });
            }
          },
          followProgress: async function (trainerId) {
            // Memorize Vue's `this`
            const this_ = this;

            const f = async function (resolve, reject) {
              var response = await fetch(
                `{{ url_for("get_status") }}?trainer_id=${trainerId}`
              );
              var data = await response.json();

              if (data.error !== undefined) {
                this_.showProgressDialog = false;
                this_.showErrorDialog = true;
                this_.errorMessage = data.error;
              } else if (data.result !== undefined) {
                this_.showProgressDialog = false;
                resolve(data.result);
              } else {
                this_.progressValue = data.progress;

                switch (data.progress) {
                  case -1:
                    this_.progressStatus = "Initializing...";
                    this_.progressMode = "query";
                    break;

                  case 100:
                    this_.progressStatus = "Finalizing...";
                    this_.progressMode = "query";
                    break;

                  default:
                    this_.progressStatus = `${data.progress}%`;
                    this_.progressMode = "determinate";
                    break;
                }

                setTimeout(f, 500, resolve, reject);
              }
            };

            this.showProgressDialog = true;

            return new Promise(f);
          },
        },
        validations: function () {
          return {
            form: {
              n: {
                required: validators.required,
                between: validators.between(1, 4),
              },
              f: {
                required: validators.required,
                between: validators.between(1, Number(this.form.n) + 1),
              },
              gar: {
                required: validators.required,
              },
            },
          };
        },
      });
    </script>
  </body>
</html>
